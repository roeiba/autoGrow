#!/usr/bin/env python3
"""
Issue Generator Agent
Ensures minimum number of open issues by generating new ones with Claude AI using Agent SDK
"""

import os
import sys
import json
from pathlib import Path
from github import Github, Auth

# Add src directory to path to import claude_cli_agent
sys.path.insert(0, str(Path(__file__).parent.parent.parent / 'src' / 'claude-agent'))

# Import Claude CLI Agent
try:
    from claude_cli_agent import ClaudeAgent
    USE_CLAUDE_CLI = True
except ImportError:
    print("âš ï¸  claude_cli_agent not available")
    sys.exit(1)

# Configuration
MIN_ISSUES = int(os.getenv('MIN_OPEN_ISSUES', '3'))
GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')
ANTHROPIC_API_KEY = os.getenv('ANTHROPIC_API_KEY')
REPO_NAME = os.getenv('REPO_NAME')

print(f"ğŸ” Checking issue count (minimum: {MIN_ISSUES})")

# Initialize GitHub client
auth = Auth.Token(GITHUB_TOKEN)
gh = Github(auth=auth)
repo = gh.get_repo(REPO_NAME)

# Count open issues (excluding pull requests)
open_issues = list(repo.get_issues(state='open'))
open_issues = [i for i in open_issues if not i.pull_request]
issue_count = len(open_issues)

print(f"ğŸ“Š Current open issues: {issue_count}")

if issue_count >= MIN_ISSUES:
    print(f"âœ… Sufficient issues exist ({issue_count} >= {MIN_ISSUES})")
    sys.exit(0)

# Need to generate issues
needed = MIN_ISSUES - issue_count
print(f"ğŸ¤– Generating {needed} new issue(s)...")


def generate_issues():
    """Use Claude CLI Agent to generate issues"""
    
    # Get repository context
    print("ğŸ“– Analyzing repository for potential issues...")
    
    try:
        readme = repo.get_readme().decoded_content.decode('utf-8')[:1000]
    except:
        readme = "No README found"
    
    recent_commits = list(repo.get_commits()[:5])
    commit_messages = "\n".join([f"- {c.commit.message.split(chr(10))[0]}" for c in recent_commits])
    
    # Build prompt for Claude
    prompt = f"""Analyze this GitHub repository and suggest {needed} new issue(s).

Repository: {REPO_NAME}

README excerpt:
{readme}

Recent commits:
{commit_messages}

Current open issues:
{chr(10).join([f"- #{i.number}: {i.title}" for i in open_issues[:10]])}

Generate {needed} realistic, actionable issue(s). Include diverse types:
1. **feature**: New functionality or enhancements
2. **bug**: Potential bugs or issues to fix
3. **documentation**: Documentation improvements
4. **refactor**: Code quality and refactoring
5. **test**: Testing improvements
6. **performance**: Performance optimizations
7. **security**: Security improvements
8. **ci/cd**: CI/CD pipeline improvements

Respond with ONLY a JSON object in this exact format:
{{
  "issues": [
    {{
      "title": "Brief title (max 80 chars)",
      "body": "Description (max 300 chars)",
      "labels": ["feature"]
    }}
  ]
}}

Use appropriate labels: feature, bug, documentation, refactor, test, performance, security, ci/cd

Keep descriptions brief and output ONLY the JSON, nothing else."""

    print(f"ğŸ“ Prompt length: {len(prompt)} chars")
    
    # Configure Claude CLI Agent
    try:
        agent = ClaudeAgent(
            output_format="text",
            verbose=False
        )
        
        print("ğŸ¤– Calling Claude AI...")
        result = agent.query(
            prompt,
            system_prompt="You are a helpful GitHub issue generator. Always respond with valid JSON only."
        )
        
        # Extract response
        if isinstance(result, dict) and "result" in result:
            response_text = result["result"]
        else:
            response_text = str(result)
        
        print(f"âœ… Received response ({len(response_text)} chars)")
        
    except Exception as e:
        print(f"âŒ Claude CLI error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
    
    # Parse response
    try:
        print("ğŸ” Parsing Claude response...")
        
        # Clean up response - remove markdown code blocks if present
        cleaned_response = response_text.strip()
        if "```json" in cleaned_response:
            cleaned_response = cleaned_response.split("```json")[1].split("```")[0].strip()
            print("ğŸ“ Removed ```json``` markers")
        elif "```" in cleaned_response:
            cleaned_response = cleaned_response.split("```")[1].split("```")[0].strip()
            print("ğŸ“ Removed ``` markers")
        
        # Find JSON object in response
        start_idx = cleaned_response.find('{')
        end_idx = cleaned_response.rfind('}') + 1
        
        if start_idx == -1 or end_idx == 0:
            raise ValueError("No JSON object found in response")
        
        json_str = cleaned_response[start_idx:end_idx]
        print(f"ğŸ“Š Extracted JSON: {len(json_str)} chars")
        
        data = json.loads(json_str)
        issues_to_create = data.get('issues', [])[:needed]
        
        if not issues_to_create:
            print("âš ï¸  No issues generated by Claude")
            return
        
        # Create issues
        for issue_data in issues_to_create:
            title = issue_data.get('title', 'Untitled Issue')[:80]  # Limit title length
            body = issue_data.get('body', '')
            labels = issue_data.get('labels', [])
            
            full_body = f"{body}\n\n---\n*Generated by Issue Generator Agent*"
            
            new_issue = repo.create_issue(
                title=title,
                body=full_body,
                labels=labels
            )
            
            print(f"âœ… Created issue #{new_issue.number}: {title}")
        
        print(f"ğŸ‰ Successfully generated {len(issues_to_create)} issue(s)")
        
    except json.JSONDecodeError as e:
        print(f"âŒ Failed to parse Claude response as JSON: {e}")
        print(f"Response (first 1000 chars): {response_text[:1000]}")
        print(f"Response (last 500 chars): {response_text[-500:]}")
        sys.exit(1)
    except Exception as e:
        print(f"âŒ Error creating issues: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


# Run the function
try:
    generate_issues()
except Exception as e:
    print(f"âŒ Fatal error: {e}")
    import traceback
    traceback.print_exc()
    sys.exit(1)
